"""
Copyright (c) 2026 Oscar Valenzuela <oscar.valenzuela.b@gmail.com>
All Rights Reserved.

Vulnerability Matcher Service

Matches tracked packages to vulnerabilities using multiple strategies:
1. Exact PURL match (with version)
2. Fuzzy PURL match (base PURL, version-agnostic)
3. GitHub URL match
4. Package name + ecosystem match

Part of Phase A: Package-Vulnerability Integration
GitHub Issue: #85
"""

import re
from typing import List, Dict, Tuple, Optional
from urllib.parse import urlparse
import asyncpg


class VulnerabilityMatcher:
    """Match tracked packages to vulnerabilities using multiple strategies."""

    def __init__(self, db_pool: asyncpg.Pool):
        """
        Initialize the matcher with a database connection pool.

        Args:
            db_pool: asyncpg connection pool for database queries
        """
        self.db_pool = db_pool

    def extract_base_purl(self, purl: str) -> str:
        """
        Strip version from PURL.

        Examples:
            pkg:npm/express@4.18.0 -> pkg:npm/express
            pkg:pypi/requests@2.28.0 -> pkg:pypi/requests
            pkg:maven/com.fasterxml.jackson.core/jackson-databind@2.14.0 -> pkg:maven/com.fasterxml.jackson.core/jackson-databind

        Args:
            purl: Package URL string

        Returns:
            Base PURL without version
        """
        if '@' in purl:
            # Split on last @ to handle maven packages with dots
            parts = purl.rsplit('@', 1)
            return parts[0]
        return purl

    def normalize_maven_purl(self, purl: str) -> List[str]:
        """
        Generate normalized Maven PURL variants for matching.

        Maven PURLs can use different separators between groupId and artifactId:
        - Package URL spec: pkg:maven/org.opensearch/opensearch (uses /)
        - Maven coordinates: pkg:maven/org.opensearch:opensearch (uses :)

        Both formats are valid and appear in different data sources.
        This method returns both variants to enable cross-format matching.

        Examples:
            pkg:maven/org.opensearch/opensearch@1.0.0 ->
                [pkg:maven/org.opensearch/opensearch@1.0.0,
                 pkg:maven/org.opensearch:opensearch@1.0.0]

            pkg:maven/org.springframework:spring-core ->
                [pkg:maven/org.springframework:spring-core,
                 pkg:maven/org.springframework/spring-core]

        Args:
            purl: Package URL string

        Returns:
            List of normalized PURL variants (always includes original)
        """
        if not purl.startswith('pkg:maven/'):
            return [purl]  # Not Maven, return as-is

        variants = [purl]  # Always include original

        # Extract the part after pkg:maven/
        maven_part = purl[10:]  # Skip 'pkg:maven/'

        # Check if we have a version
        version_part = ''
        if '@' in maven_part:
            maven_part, version_part = maven_part.rsplit('@', 1)
            version_part = '@' + version_part

        # Generate alternate format
        if '/' in maven_part:
            # Current format: org.opensearch/opensearch
            # Generate alternate: org.opensearch:opensearch
            alternate = maven_part.replace('/', ':', 1)  # Replace first / with :
            variants.append(f"pkg:maven/{alternate}{version_part}")
        elif ':' in maven_part:
            # Current format: org.opensearch:opensearch
            # Generate alternate: org.opensearch/opensearch
            alternate = maven_part.replace(':', '/', 1)  # Replace first : with /
            variants.append(f"pkg:maven/{alternate}{version_part}")

        return variants

    def extract_github_repo(self, url: str) -> Optional[str]:
        """
        Extract owner/repo from GitHub URL.

        Examples:
            https://github.com/psf/requests -> psf/requests
            https://github.com/expressjs/express/ -> expressjs/express
            git@github.com:psf/requests.git -> psf/requests

        Args:
            url: GitHub URL string

        Returns:
            owner/repo string or None if not a GitHub URL
        """
        if not url:
            return None

        # Handle different GitHub URL formats
        patterns = [
            r'github\.com[:/]([^/]+)/([^/\.]+)',  # https://github.com/owner/repo or git@github.com:owner/repo
        ]

        for pattern in patterns:
            match = re.search(pattern, url)
            if match:
                owner, repo = match.groups()
                return f"{owner}/{repo}"

        return None

    def extract_package_name_from_purl(self, purl: str) -> Tuple[Optional[str], Optional[str]]:
        """
        Extract ecosystem and package name from PURL.

        Examples:
            pkg:npm/express -> ('npm', 'express')
            pkg:pypi/requests -> ('PyPI', 'requests')
            pkg:maven/com.fasterxml.jackson.core/jackson-databind -> ('Maven', 'com.fasterxml.jackson.core/jackson-databind')

        Args:
            purl: Package URL string

        Returns:
            Tuple of (ecosystem, package_name) or (None, None) if parsing fails
        """
        if not purl.startswith('pkg:'):
            return None, None

        # Remove pkg: prefix
        purl_body = purl[4:]

        # Split on first /
        parts = purl_body.split('/', 1)
        if len(parts) < 2:
            return None, None

        ecosystem_raw = parts[0]
        package_part = parts[1]

        # Remove version if present
        if '@' in package_part:
            package_part = package_part.rsplit('@', 1)[0]

        # Map PURL ecosystem to vulnerability database ecosystem
        ecosystem_map = {
            'npm': 'npm',
            'pypi': 'PyPI',
            'maven': 'Maven',
            'golang': 'Go',
            'cargo': 'crates.io',
            'gem': 'RubyGems',
            'nuget': 'NuGet',
            'composer': 'Packagist',
            'hex': 'Hex',
            'pub': 'Pub',
            'github': 'GitHub Actions',
        }

        ecosystem = ecosystem_map.get(ecosystem_raw.lower(), ecosystem_raw)

        return ecosystem, package_part

    async def match_package_vulnerabilities(
        self,
        package_id: int,
        purl: str,
        github_url: Optional[str] = None,
        ecosystem: Optional[str] = None,
        name: Optional[str] = None
    ) -> List[Dict]:
        """
        Find all vulnerabilities for a package using multiple strategies.

        Strategies (in order of preference):
        1. Exact PURL match (most reliable)
        2. Fuzzy PURL match (version-agnostic)
        3. GitHub URL match (for packages with known repo)
        4. Package name + ecosystem match (fallback)

        Args:
            package_id: ID of the tracked package
            purl: Package URL
            github_url: Optional GitHub repository URL
            ecosystem: Optional ecosystem name
            name: Optional package name

        Returns:
            List of dictionaries with vulnerability matches:
            [
                {
                    'vulnerability_id': 123,
                    'matched_via': 'purl_exact',
                    'vuln_id': 'GHSA-xxxx-yyyy-zzzz',
                    'cve_id': 'CVE-2024-1234',
                    'severity': 'CRITICAL'
                },
                ...
            ]
        """
        matches = []
        matched_vuln_ids = set()  # Track to avoid duplicates

        async with self.db_pool.acquire() as conn:
            # Strategy 1: Exact PURL match (with Maven normalization)
            # For Maven packages, try both format variants (: and / separators)
            purl_variants = self.normalize_maven_purl(purl)

            for purl_variant in purl_variants:
                exact_matches = await conn.fetch(
                    """
                    SELECT id, vuln_id, cve_id, severity
                    FROM vulnerabilities
                    WHERE purl = $1
                    """,
                    purl_variant
                )

                for row in exact_matches:
                    vuln_id = row['id']
                    if vuln_id not in matched_vuln_ids:
                        matches.append({
                            'vulnerability_id': vuln_id,
                            'matched_via': 'purl_exact',
                            'vuln_id': row['vuln_id'],
                            'cve_id': row['cve_id'],
                            'severity': row['severity']
                        })
                        matched_vuln_ids.add(vuln_id)

            # Strategy 2: Fuzzy PURL match (base PURL without version, with Maven normalization)
            base_purl = self.extract_base_purl(purl)
            if base_purl != purl:  # Only if we actually stripped a version
                # For Maven packages, try both format variants
                base_purl_variants = self.normalize_maven_purl(base_purl)

                for base_variant in base_purl_variants:
                    fuzzy_matches = await conn.fetch(
                        """
                        SELECT id, vuln_id, cve_id, severity, purl
                        FROM vulnerabilities
                        WHERE purl LIKE $1 || '%' OR purl = $1
                        """,
                        base_variant
                    )

                    for row in fuzzy_matches:
                        vuln_id = row['id']
                        if vuln_id not in matched_vuln_ids:
                            matches.append({
                                'vulnerability_id': vuln_id,
                                'matched_via': 'purl_fuzzy',
                                'vuln_id': row['vuln_id'],
                                'cve_id': row['cve_id'],
                                'severity': row['severity']
                            })
                            matched_vuln_ids.add(vuln_id)

            # Strategy 3: GitHub URL match
            if github_url:
                github_repo = self.extract_github_repo(github_url)
                if github_repo:
                    github_matches = await conn.fetch(
                        """
                        SELECT id, vuln_id, cve_id, severity
                        FROM vulnerabilities
                        WHERE github_repo_url LIKE '%' || $1 || '%'
                        """,
                        github_repo
                    )

                    for row in github_matches:
                        vuln_id = row['id']
                        if vuln_id not in matched_vuln_ids:
                            matches.append({
                                'vulnerability_id': vuln_id,
                                'matched_via': 'github_url',
                                'vuln_id': row['vuln_id'],
                                'cve_id': row['cve_id'],
                                'severity': row['severity']
                            })
                            matched_vuln_ids.add(vuln_id)

            # Strategy 4: Package name + ecosystem match
            if not ecosystem or not name:
                # Try to extract from PURL
                ecosystem, name = self.extract_package_name_from_purl(purl)

            if ecosystem and name:
                name_matches = await conn.fetch(
                    """
                    SELECT id, vuln_id, cve_id, severity
                    FROM vulnerabilities
                    WHERE ecosystem = $1 AND package_name = $2
                    """,
                    ecosystem,
                    name
                )

                for row in name_matches:
                    vuln_id = row['id']
                    if vuln_id not in matched_vuln_ids:
                        matches.append({
                            'vulnerability_id': vuln_id,
                            'matched_via': 'package_name',
                            'vuln_id': row['vuln_id'],
                            'cve_id': row['cve_id'],
                            'severity': row['severity']
                        })
                        matched_vuln_ids.add(vuln_id)

        return matches

    async def link_vulnerabilities(
        self,
        package_id: int,
        purl: str,
        github_url: Optional[str] = None,
        ecosystem: Optional[str] = None,
        name: Optional[str] = None
    ) -> int:
        """
        Match and link vulnerabilities to a package in the database.

        This method:
        1. Finds all matching vulnerabilities
        2. Inserts/updates entries in tracked_package_vulnerabilities table
        3. Returns count of vulnerabilities linked

        Args:
            package_id: ID of the tracked package
            purl: Package URL
            github_url: Optional GitHub repository URL
            ecosystem: Optional ecosystem name
            name: Optional package name

        Returns:
            Number of vulnerabilities linked
        """
        # Find matches
        matches = await self.match_package_vulnerabilities(
            package_id=package_id,
            purl=purl,
            github_url=github_url,
            ecosystem=ecosystem,
            name=name
        )

        if not matches:
            return 0

        # Insert into junction table
        async with self.db_pool.acquire() as conn:
            linked_count = 0
            for match in matches:
                try:
                    await conn.execute(
                        """
                        INSERT INTO tracked_package_vulnerabilities
                            (package_id, vulnerability_id, matched_via, last_checked_at)
                        VALUES ($1, $2, $3, NOW())
                        ON CONFLICT (package_id, vulnerability_id)
                        DO UPDATE SET
                            last_checked_at = NOW(),
                            matched_via = EXCLUDED.matched_via
                        """,
                        package_id,
                        match['vulnerability_id'],
                        match['matched_via']
                    )
                    linked_count += 1
                except Exception as e:
                    print(f"Error linking vulnerability {match['vulnerability_id']} to package {package_id}: {e}")
                    continue

        return linked_count
