-- ============================================================
-- Migration 002: Vulnerability Data Schema
-- ============================================================
-- Purpose: Create tables for storing vulnerability, package, and media data
-- Replaces: DuckDB storage (eliminates race conditions)
-- Date: 2026-01-07

-- ============================================================
-- VULNERABILITIES TABLE
-- ============================================================
DROP TABLE IF EXISTS vulnerabilities CASCADE;

CREATE TABLE vulnerabilities (
    id SERIAL PRIMARY KEY,
    vuln_id VARCHAR(100) UNIQUE NOT NULL,
    ecosystem VARCHAR(50) NOT NULL,
    package_name VARCHAR(255) NOT NULL,
    purl VARCHAR(500),
    cve_id VARCHAR(50),
    severity VARCHAR(20),
    cvss_score DECIMAL(3,1),
    epss_score DECIMAL(10,8),
    summary TEXT,
    details TEXT,
    affected_versions JSONB,
    fixed_version VARCHAR(100),
    published TIMESTAMP,
    modified TIMESTAMP,
    withdrawn TIMESTAMP,
    source VARCHAR(50) NOT NULL,
    source_url VARCHAR(500),
    references_list JSONB,
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW()
);

-- Indexes for fast lookups
CREATE INDEX IF NOT EXISTS idx_vuln_ecosystem ON vulnerabilities(ecosystem);
CREATE INDEX IF NOT EXISTS idx_vuln_package ON vulnerabilities(package_name);
CREATE INDEX IF NOT EXISTS idx_vuln_cve ON vulnerabilities(cve_id) WHERE cve_id IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_vuln_severity ON vulnerabilities(severity);
CREATE INDEX IF NOT EXISTS idx_vuln_published ON vulnerabilities(published DESC);
CREATE INDEX IF NOT EXISTS idx_vuln_package_eco ON vulnerabilities(ecosystem, package_name);

-- Full-text search on summary and details
CREATE INDEX IF NOT EXISTS idx_vuln_search ON vulnerabilities USING gin(to_tsvector('english', COALESCE(summary, '') || ' ' || COALESCE(details, '')));

-- ============================================================
-- PACKAGES TABLE
-- ============================================================
DROP TABLE IF EXISTS packages CASCADE;

CREATE TABLE packages (
    id SERIAL PRIMARY KEY,
    purl VARCHAR(500) UNIQUE NOT NULL,
    ecosystem VARCHAR(50) NOT NULL,
    name VARCHAR(255) NOT NULL,
    version VARCHAR(100),
    repository_url VARCHAR(500),
    homepage_url VARCHAR(500),


    health_score INTEGER CHECK (health_score >= 0 AND health_score <= 100),
    health_grade VARCHAR(2),
    risk_level VARCHAR(20),


    stars INTEGER,
    forks INTEGER,
    watchers INTEGER,
    open_issues INTEGER,
    last_commit_date TIMESTAMP,
    commit_frequency DECIMAL(5,2),
    contributor_count INTEGER,
    maintainer_count INTEGER,


    license VARCHAR(100),
    description TEXT,
    keywords JSONB,
    dependencies_count INTEGER,
    dev_dependencies_count INTEGER,
    total_dependencies INTEGER,


    critical_vulns INTEGER DEFAULT 0,
    high_vulns INTEGER DEFAULT 0,
    medium_vulns INTEGER DEFAULT 0,
    low_vulns INTEGER DEFAULT 0,
    total_vulns INTEGER DEFAULT 0,


    last_analyzed TIMESTAMP,
    analysis_version VARCHAR(20),
    metadata JSONB,

    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW()
);

-- Indexes for packages
CREATE INDEX IF NOT EXISTS idx_pkg_ecosystem ON packages(ecosystem);
CREATE INDEX IF NOT EXISTS idx_pkg_name ON packages(name);
CREATE INDEX IF NOT EXISTS idx_pkg_health_score ON packages(health_score DESC);
CREATE INDEX IF NOT EXISTS idx_pkg_risk_level ON packages(risk_level);
CREATE INDEX IF NOT EXISTS idx_pkg_last_analyzed ON packages(last_analyzed DESC);
CREATE INDEX IF NOT EXISTS idx_pkg_ecosystem_name ON packages(ecosystem, name);

-- Full-text search on package name and description
CREATE INDEX IF NOT EXISTS idx_pkg_search ON packages USING gin(to_tsvector('english', name || ' ' || COALESCE(description, '')));

-- ============================================================
-- MEDIA ITEMS TABLE
-- ============================================================
DROP TABLE IF EXISTS media_items CASCADE;

CREATE TABLE media_items (
    id SERIAL PRIMARY KEY,
    item_id VARCHAR(255) UNIQUE NOT NULL,
    source VARCHAR(50) NOT NULL,
    source_type VARCHAR(20) NOT NULL,


    title TEXT NOT NULL,
    url VARCHAR(1000),
    content TEXT,
    author VARCHAR(255),


    published TIMESTAMP NOT NULL,
    scraped_at TIMESTAMP DEFAULT NOW(),


    sentiment VARCHAR(20),
    sentiment_score DECIMAL(3,2),
    risk_level VARCHAR(20),
    risk_score INTEGER CHECK (risk_score >= 0 AND risk_score <= 100),


    packages_mentioned JSONB,
    vulnerabilities_mentioned JSONB,


    ai_summary TEXT,
    ai_analysis JSONB,
    keywords JSONB,
    categories JSONB,


    score INTEGER,
    comments_count INTEGER,

    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW()
);

-- Indexes for media items
CREATE INDEX IF NOT EXISTS idx_media_source ON media_items(source);
CREATE INDEX IF NOT EXISTS idx_media_published ON media_items(published DESC);
CREATE INDEX IF NOT EXISTS idx_media_sentiment ON media_items(sentiment);
CREATE INDEX IF NOT EXISTS idx_media_risk ON media_items(risk_level);
CREATE INDEX IF NOT EXISTS idx_media_packages ON media_items USING gin(packages_mentioned);

-- Full-text search on title and content
CREATE INDEX IF NOT EXISTS idx_media_search ON media_items USING gin(to_tsvector('english', title || ' ' || COALESCE(content, '')));

-- ============================================================
-- PACKAGE VULNERABILITIES (Many-to-Many)
-- ============================================================
DROP TABLE IF EXISTS package_vulnerabilities CASCADE;

CREATE TABLE package_vulnerabilities (
    id SERIAL PRIMARY KEY,
    package_id INTEGER REFERENCES packages(id) ON DELETE CASCADE,
    vulnerability_id INTEGER REFERENCES vulnerabilities(id) ON DELETE CASCADE,
    affects_version BOOLEAN DEFAULT TRUE,
    is_fixed BOOLEAN DEFAULT FALSE,
    discovered_at TIMESTAMP DEFAULT NOW(),
    UNIQUE(package_id, vulnerability_id)
);

CREATE INDEX IF NOT EXISTS idx_pkg_vuln_package ON package_vulnerabilities(package_id);
CREATE INDEX IF NOT EXISTS idx_pkg_vuln_vuln ON package_vulnerabilities(vulnerability_id);

-- ============================================================
-- TRIGGERS FOR updated_at
-- ============================================================
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER update_vulnerabilities_updated_at BEFORE UPDATE ON vulnerabilities
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_packages_updated_at BEFORE UPDATE ON packages
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_media_items_updated_at BEFORE UPDATE ON media_items
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

-- ============================================================
-- VIEWS FOR COMMON QUERIES
-- ============================================================

-- High-risk packages (critical/high vulnerabilities)
CREATE OR REPLACE VIEW high_risk_packages AS
SELECT
    p.id,
    p.purl,
    p.ecosystem,
    p.name,
    p.version,
    p.health_score,
    p.health_grade,
    p.critical_vulns,
    p.high_vulns,
    p.total_vulns,
    p.last_analyzed
FROM packages p
WHERE p.critical_vulns > 0 OR p.high_vulns > 0
ORDER BY p.critical_vulns DESC, p.high_vulns DESC;

-- Recent vulnerabilities (last 30 days)
CREATE OR REPLACE VIEW recent_vulnerabilities AS
SELECT
    v.vuln_id,
    v.ecosystem,
    v.package_name,
    v.cve_id,
    v.severity,
    v.cvss_score,
    v.summary,
    v.published
FROM vulnerabilities v
WHERE v.published >= NOW() - INTERVAL '30 days'
ORDER BY v.published DESC;

-- High-impact media (high risk + high engagement)
CREATE OR REPLACE VIEW high_impact_media AS
SELECT
    m.item_id,
    m.source,
    m.title,
    m.url,
    m.published,
    m.risk_level,
    m.risk_score,
    m.sentiment,
    m.score,
    m.packages_mentioned
FROM media_items m
WHERE
    m.risk_level IN ('CRITICAL', 'HIGH')
    OR m.score > 100
ORDER BY m.published DESC;

-- ============================================================
-- COMMENTS
-- ============================================================
COMMENT ON TABLE vulnerabilities IS 'Security vulnerabilities from OSV, NVD, GHSA, EPSS';
COMMENT ON TABLE packages IS 'Tracked open source packages with health metrics';
COMMENT ON TABLE media_items IS 'News, blog posts, and social media mentions';
COMMENT ON TABLE package_vulnerabilities IS 'Many-to-many relationship between packages and vulnerabilities';

COMMENT ON COLUMN vulnerabilities.epss_score IS 'Exploit Prediction Scoring System (0.0-1.0)';
COMMENT ON COLUMN packages.health_score IS 'Overall package health score (0-100)';
COMMENT ON COLUMN media_items.sentiment_score IS 'AI sentiment analysis (-1.0 negative to +1.0 positive)';
